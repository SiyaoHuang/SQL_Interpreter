# cs4321_p1
## Prerequisite
- Maven v.10.0  
- Oracle JDK 1.8  
## Installation
- Build

    ```
    mvn package
    ```
    The output **.jar** will be built in **/Target**  
    **Bug**: The jar generated by maven cannot be run due to the system scope dependency. Please adjust it to complie or use ```mvn install``` to install the package in maven's dependencies management folder.
- IDE

    If you want to use Eclipse, try the command below:  
    ```
    mvn eclipse:eclipse
    ```
## Implement
-  **Top-level class** is ```com.sql.interpreter.App```
-  The runnable jar could be run in cmd 

    ```java -jar cs4321 p1.jar $<inputdir> $<outputdir>```
## Details
**1. Query Plan(Operator Tree)**
  
- After each scan operation, we implement a select operation if there exists related expression in where section.
- Then we implement join operation if exists. The detailed join operation will be illustrated below.
- After all tables are joined, we implement the projection, sort and distinct operation in order if they exist in the query statement.

    e.g.
    ```
    SELECT DISTINCT S.A, B.D 
    FROM Sailors As S, Reserves As R, Boats As B 
    WHERE R.H = B.D and S.A = R.G and B.D = 101 
    ORDER BY S.A

                                 Distinct
                                    |
                                  Order
                                    |
                                 Project
                                    |
                                Join with B
                    (R.H = B.D and S.A = R.G and B.D = 101)
                                /        \
                            Join S, R    select
                           (S.A = R.G)   (B.D = 101)
                           /        \       |
                        Scan S    Scan R   scan B
                                      
    ```
    When join with B, we take the whole expression as the join condition, instead of ```S.A = R.G```, since there will be no difference to I/Os.

**2. Join Expression Visitor**
- **How to evaluate a Join condition**
    1. Extract the related expression (Join condition), according to the current schema. We will demonstrate how to do this and some examples as below.
    2. Use the refined expression to accept the SelectExpressionVisitor to make the evaluation.
   
   Thus, the Join Expression Visitor only targets to realize step 1.

- **Rules**  
    1. We call an expression valid as they only use the column appeared in the current schema.
    2. For a ```AndExpression```:  
     If both the right and left expressions in stack are valid, ```left and right``` will be seem as valid.   
     If only either one is valid, we will return this valid expression to the parent node via keep it in stack.    
     If none valid, return back null.
    3. For a ``OrExpression`:   
     If either one of left or right expression is valid, returns back null(replace the stack by null)   
     Otherwise, return the ```left or right```
    4. ```LongValue``` is valid. The ```colume``` will be judged valide when the column is appeared in schema.
    5. For ```comparasion``` expression, it is similiar as ```OrExpression```.
- **Examples**  
  current schema only contains table S and R, without B.  
  ```
  S.A = B.C                             -> null
  S.A = B.C or XXX                      -> null
  S.A > 3 and B.C = R.G and R.G < S.A   -> S.A > 3 and R.G < S.A
  ```
- **Java doc**  
__*JoinExpressionVisitor*__ lays in ```src/main/java/util/```, so does __*SelectExpressionVisitor*__.  
The related comments are added on the related functions.

**3. Select Expression Visitor**
- **Principles** 
If we see select expressions as a tree, then they need to be evaluated 
from the bottom layer up to top, which means previous result would be used 
in later expressions. Thus, we use stacks to store the results. 
Since each expression has two sides, left and right. We need to 
store both left and right results accordingly into the stack. 
Since results can be int type or boolean type, we have two kind of stacks:
the first which is int type stores results in data form and the second 
stores results in boolean form. 

- **Implementation** 
This is implemented by a Deque<Long> and a Deque<Boolean> in Java.

Using the visitor pattern, 9 visitor methods are overridden which have parameter 
in AndExpression, Column, LongValue, EqualsTo, NotEqualsTo, GreaterThan, GreaterThanEquals, 
MinorThan, MinorThanEquals respectively.

Implementation of visit method for Column Expression:
    get the data in the current tuple of the certain column and push it to data stack.
   
Implementation of visit method for Long Expression:
    just push the long value of the expression to the data stack.

Implementation of Each visit method except for Column and Long expression:
    1. the left side of the expression accepts the visitor
    2. the right side of expression accepts the visitor
    3. get the right result by pop the stack
    4. get the left result by pop the stack
    5. push the evaluation of the expression using results of both sides into stack.

- **Java doc**  
__*SelectExpressionVisitor*__ lays in ```src/main/java/util/```.
The related Java docs are added on the related functions.

